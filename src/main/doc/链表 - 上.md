### 什么是链表？

一种比较复杂的数据结构。通过“指针”将零散的内存块串联起来的一种内存结构。

+ 结点：零散的内存块
+ 后继指针next：下一个结点的指针
+ 头结点
+ 尾结点：其后继指针指向空地址NULL

### 常见的链表结构

1. 单链表

   每个节点只包含数据和一个后继指针

2. 循环链表

   对比单链表，尾节点的后继指针不指向 NULL 而是指向 头结点

   应用场景：“约瑟夫问题”等

3. 双向链表

   特点：有前驱指针和后继指针

   设计思想：空间换时间，延伸其他设计：CPU缓存、数据库缓存、浏览器缓存、数据库设计的冗余字段

4. 双向循环链表

   对比双向链表，通过头结点的前驱指针和尾节点的后继指针将头节点和尾节点连接起来

### 链表操作的复杂度分析

#### 常规操作

1. 插入

   单纯插入：O(1)

   查找插入：O(n)

2. 删除

   单纯删除：O(1)

   查找删除：O(n)

3. 查询：O(n)

#### 具体场景

1. 删除节点中“值等于某个给定值”的节点

   分析：需要先查找，再删除

   加法原则，计算结果：O(n)

2. 删除给定指针指向的节点

   分析：删除完成后，还需要将上一个节点的后继指针指向新的节点

   单向链表：需要遍历,复杂度 O(n)

   双向链表：可以通过前驱指针找到，复杂度O(1)

### 数组和链表的性能对比

#### 复杂度对比

![数据和链表操作复杂度对比](pic/数据和链表操作复杂度对比.jpg)

#### 内存特点对比

数组：
优势：内存连续，可借助CPU的缓存机制（程序局部性原理），预读数组中的数据，访问效率较高
缺点：内存大小固定。在创建数据时就确定了其大小，不支持动态扩容

链表：
缺点：内存不连续，没办法预读。此外数据频繁的插入删除，导致内存碎片，如果是Java可能会引发GC。
优势：在创建时不要求内存连续，也可动态扩容。

### 缓存的LRU淘汰策略实现

通过有序的单链表来实现

实现细节：

1. 添加新数据，如果缓存中已经存在，则其对应的结点移动至链表头部
2. 添加新数据，如果缓存中不存在
   + 超过缓存容量，删除链表的尾节点，新数据插入链表头部
   + 未超过缓存容量，直接将新数据插入到链表头部

简单代码实现：com.gold.algorithm.learnblock.list

优化
问题：访问缓存的数据复杂度，由于需要遍历链表，时间复杂度为O(n)
优化方案：引入散列表，记录数据的位置



