### 散列表存在的问题

散列冲突，可能会使得时间复杂度 从 O(1) -> O(n)，要尽可能解决避免，要从散列函数触发

### 散列函数

#### 要求

1. 不能太复杂：保证计算效率

2. 散列函数计算的值要尽可能随机且平均分布

   举例：可以截取数据的某些部分，作为散列值。或者 ASCII码 值进位相加 取模

### 散列表的动态扩容

1. 扩容根据：根据装载因子的大小，判断散列表的空闲程度，决定是否扩容或者缩容

2. 扩容过程

   + 随着数据的插入，达到装载因子的阈值，决定扩容
   + 先申请比原来大的新的散列表，再进行数据的迁移。时间复杂度O(n)

3. 缩容过程类似

4. 避免低效扩容

   核心：不一次性进行数据的迁移，均摊到每次数据的插入时机

### 选择冲突的解决方式

1. 开放寻址法
   + 优势
     + 相比较链表法，它没有链表结构，则可以李荣CPU的缓存
     + 序列化简单
   + 缺点
     + 删除操作麻烦
     + 冲突代价高
   + 适合场景：数据量小的，装载因子小的，比如 ThreadLocalMap
2. 链表法
   + 优点
     + 内存利用率比较高
     + 对大的装载因子容忍度高
   + 缺点
     + 内存不连续，CPU缓存不友好
   + 适合场景：数据量大的、大对象，支持更多的优化策略，比如链表变为红黑树

### Java HashMap 分析

+ 初始大小：16
+ 加载因子：0.75 --- 当元素个数超过 16*0.75，则散列表会进行扩容
+ 散列冲突的解决办法
  + 使用链表法
  + 当链表的长度为8时，链表变为红黑树
  + 当链表的长度为6时，红黑树变为链表
+ 散列函数：比较简单

### 问题

1. 如何设计一个工业级的散列表？

   思考维度：

   + 散列函数：不复杂、平均、随机
   + 装载因子的阈值及动态扩容 ：保持散列表的操作效率
   + 选择合适的散列冲突的解决办法

### 