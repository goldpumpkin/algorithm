### 如何选择合适的算法

#### 各算法的性能分析

![各算法性能分析总结](pic/各算法性能分析总结.jpeg)

#### 各算法一般选择

+ 数量级较小的可以用 O(n^2) : 冒泡、插入、选择
+ 大规模数据可以选择：O(nlogn)：归并(非原地排序)、快排
+ 特殊场景：桶、技术、基数

### 如何优化快排

#### 分区点的选择

优化点：快排在最坏的情况下，时间复杂度会退化到O(n^2)，和选择的分区点有关系。如果分区点是某一个端点(最左端和最右端)，那么快排的时间复杂度是O(n^2)。最理想的情况下，被分区点分开的两个区域的元素数量差不多。因此，需要优化的是 **分区点的选择**

#### 递归避免堆栈的方法

1. 设置阈值，当达到阈值后，不在进行递归
2. 在堆上自行实现调用栈，手动模拟函数调用的入栈和出栈过程，从而绕开系统调用栈大小的限制

#### 优化方法

+ 三数取中法
+ 随机法

### Glibc 中的 qsort() 函数分析

#### 算法内容

+ 数据量 <= 4，插入排序
+ 数据量较小，归并排序
+ 数据量较大，快速排序，分区点的选择使用「三数取中法」
+ 利用哨兵优化代码

### 问题

1. O(n2) 时间复杂度的算法并一定比 O(nlogn) 的算法执行时间长吗？

   不一定。

   时间复杂度是对算法的理论分析，分析的是随着数据规模的增长，执行时间的增长趋势。分析的时候省去了系数、低阶、常数。

2. Java 语言的排序用的是什么排序算法？

   Arrays.sort

   长度小于47：插入排序，包含普通插入排序和成对插入排序
   长度小于286：快排，选择了两个pivote
   长度大于286：检查数据是否有序，使用TimeSort或者快排

   