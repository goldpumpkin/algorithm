### 排序算法分析维度

#### 1. 排序算法的执行效率

1. 最好最坏平均时间复杂度 - 目的为了对比不同待排序数据下，排序算法的表现
2. 时间复杂度的常数、系数、低阶 - 实际情况的数据规模不同
3. 比较和交换（移动）次数

#### 2. 排序算法的内存消耗

空间复杂度来评判。原地排序-空间复杂度为O(1)的算法——冒泡、插入、选择

#### 3. 排序算法的稳定性

稳定性：待排序元素中，相等元素的位置，在排序后不变，则是稳定的。否则，为不稳定

稳定排序算法：冒泡、插入

非稳定算法：选择

### Bubble Sort

1. 算法思想：每次找到待排序元素中最大(或最小)的数字，放到正确的位置。当某次循环发现，不需要移动元素，则排序已完成

2. 代码见：

3. 分析

   + 是稳定的吗？

     稳定的

   + 是原地排序算法吗

     是

   + 复杂度分析

     + 最好：O(n)

     + 最坏：O(n^2)

     + 平均：O(n^2)

       最好情况下-逆序度：0

       最坏情况下-逆序度： (n-1)n/2

       平均情况下-逆序度：(n-1)n/4 

4. 「有序度」和「逆序度」

   + 有序度：有序元素对个数

     `有序元素对：a[i] <= a[j], 如果i < j。`   例如：[2,4,1]中，有序元素对:(2,4),则有序度为1

   + 逆序度：逆序元素对个数

     `逆序元素对：a[i] > a[j], 如果i < j。` 例如：[2,4,1]中，逆序元素对:(2,4),(2,1),(4,1),则逆序度为3

   + 满有虚度

     排好序数组的有序度，等于 (n-1)n/2

   + 计算

     逆序度 = 满有序度 - 有序度

     逆序度在某些排序算法中，可等于元素的交换次数

### Insertion Sort

1. 算法思想：在待排序元素中分区分「已排序」和「未排序」两个分区，从第一个元素开始，第一个元素之前为「已排序」，后为「未排序」。每次循环从「未排序」中拿一个元素，到「已排序」区域进行**插入**，则「已排序」区间渐渐变大，「未排序」区间渐渐缩小，直到全部元素都是已排序。

   其中插入点查找可以分为：从头到尾、从尾到头

2. 代码见：

3. 分析

   + 是稳定的吗？

     稳定的

   + 是原地排序算法吗

     是

   + 复杂度分析

     + 最好：O(n) - 从尾到头查找

     + 最坏：O(n^2)

     + 平均：O(n^2)

       在数组中插入数据的平均时间复杂度O(n)，循环n次，那么就是O(n^2)

### Selection Sort

1. 算法思想：遍历数组，每次找到剩余待排序数组中最小的元素，放置到第已排好元素的后面

2. 代码见：

3. 分析

   + 是稳定的吗？

     不是， eg：[5,  3, 4, 5, 1]

   + 是原地排序算法吗

     是

   + 复杂度分析

     + 最好：O(n^2) 

       不论待排序数组是有序还是无序的，都会进行元素和元素之后的元素进行比价的操作

     + 最坏：O(n^2)

     + 平均：O(n^2)

### 问题

1. 为什么插入排序要比冒泡排序更受欢迎呢？

   + 插入排序的代码实现比冒泡排序简单点
   + 插入排序的耗时较短
   + 插入排序可进行优化 --- 希尔排序

2. 排序算法分析的维度有哪些？冒泡 插入 选择排序的算法复杂度分析

   ![排序(上)-冒泡插入选择](pic/排序(上)-冒泡插入选择.jpg)

3. 平均算法分析的另外方法是什么？

4. 如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？

5. 选择排序和冒泡排序的区别是什么？

   算法思维不同，选择排序是有分区，并且是在未排序的区域找到最小的。冒泡排序，是比较相邻两个位置的元素

