### 应用一：优先队列

#### 合并有序小文件

问题描述：100个有序小文件，合并成一个大的有序文件

解决：

1.  思路一

   在内存中，维护一个100长度的数组，第一次将每100个文件首个字节，放入数组中，比较数组中的数据，拿一个最小的放到大文件中，之后补位数组，后面依次继续。

2. 思路二

   区别于内存中的数组，这次可以维护一个「小顶堆」，每次拿堆顶元素

#### 高性能定时器

1. 场景描述

   维护任务列表，定时器每次间隔固定时间扫描列表，并执行任务。

   此方案缺陷是：定时器每次都要间隔固定时间去扫描，可能会做无用功；每次扫描列表，列表数据量大，会比较耗时

2. 改进

   目的：定时器不按照固定间隔时间扫描

   方案：将任务列表维护成一个「小顶堆」，定时器的执行时间就是「小顶堆」的堆顶元素的时间，也不用扫描整个任务列表，性能提升了

### 应用二：求 Top K

#### 静态数据集合

1. 维护数据量为 K 的 「小顶堆」，遍历数据集合，遇到比堆顶元素大数据，删除堆顶元素，添加此元素到堆中
2. 遍历的时间复杂度 O(n)，堆的一次操作O(logK)，最坏的时间的复杂度 O(nlogK)

#### 动态数据集合

思路和静态数据集合情况一样

### 应用三：求中位数

#### 问题描述

中位数：数据量是奇数，中位数是排序后处于$n/2 + 1$的位置；数据量是奇数，中位数是排序后 中间两个位置数据的任意一个。

#### 解决方案

1. 静态数据

   先排序，根据数据量取值

2. 动态数据

   + 静态数据方案，每次都要排序，效率较低

   + 堆方案

     维护两个堆，「大顶堆」— 存放前半部分数据 和「小顶堆」— 存放后半部分数据。如果数字小于等于「大顶堆」的堆顶，则放入「大顶堆」中，否则放入「小顶堆」中，并移动堆中元素，保证两个堆中的元素个数符合可以计算中位数约定的数量

#### 类似问题-响应时间99线的计算

和「求中位数」的思路一样，只不过两个堆的数量不同而已，大小堆的数量比是 99:1 

### 问题

1. 包含10亿个搜索关键词的日志文件，如何能快速获取到热门榜 Top10 的搜索关键词呢？

   + 思路一

     + 数据结构

       +  快速查找、插入数据：散列表、平衡二叉树。。。
       + 小顶堆

     + 过程

       一次性拉进内存，统计每个关键词的出现的次数，维护一个大小为10的小顶堆即可

     + 问题

       如果平均一个关键词是 50，大于需要5GB内存空间。

   + 思路二

     + 数据结构不变
     + 把原10亿个关键词，分成10个文件，对每个文件进行统计即堆化
     + 把10个堆合成一个大小为10的堆