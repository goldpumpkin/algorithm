### 什么是查找二叉树

Binary Search Tree 也叫「二叉搜索树」，二叉查找树中的任意节点，其左子节点小于本节点，其右节点大于本节点

### 查找二叉树的操作

1. 查找

2. 增

3. 删

   + 被删除节点的情况
     + 删除的节点没有子节点

     + 删除的节点有一个子节点

     + 删除的节点有两个子节点

       + 方案一：找到右子树的最小节点，将其搬运到删除节点的位置
       + 方案二：左子树中的最大值来替换待删除节点

       ![delete-node](pic/delete-node.jpeg)

   + 删除节点的其它方式

     把节点标记为删除状态，但是比较消耗内存

4. 其他操作

   + 查找最大节点
   + 查找最小节点
   + 前驱节点
   + 后继节点

5. 重要特性

   中序遍历将得到有序的数据，时间复杂度为O(n)

### 重复数据的插入和查找

1. 插入

   + 方式一：相同的数据组成一个链表或者数组，放置在同一个节点位置
   + 方式二：放置到右子树，此方式注意查找

2. 查找

   方式二的查找，比如遍历完右子树

   ![相同节点查找](pic/相同节点查找.jpeg)

### 操作的时间复杂度分析

1. 最坏的情况 - 链表 O(n)

2. 最好的情况 - 完全二叉树

   根据操作的实现来看，时间复杂度和查找二叉树的高度成正比，高度越低，时间复杂度越小。完全二叉树的高度小于等于 log2n，所以左右子树接近平衡的二叉树，时间复杂度为O(logn)

3. 理解

   每次操作后数据量都减少了一半，所以复杂度自然是logN

### 问题

1. 散列表很高效，为什么还需要二叉查找树？
   + 输出顺序数据
     + 散列表中的元素是无序存储的，先遍历再排序
     + 二叉树的中序遍历，复杂度O(n)
   + 扩容
     + 散列表扩容很耗时，性能不稳定
     + 平衡二叉树，时间复杂度稳定在O(logn)
   + 操作的效率
     + 散列表存在哈希冲突，并且哈希函数的耗时，效率不一定比O(logn)快
   + 数据结构的构造复杂度
     + 散列表：需要考虑哈希冲突、哈希函数的设计、扩容、缩容等
     + 平衡二叉树：只需要考虑平衡性，且方案成熟
   + 散列表中，装载因子不能过大，否则冲突概率会增加
2. 如何通过编程，求出一棵给定二叉树的确切高度呢？
   + 深度遍历
   + 层次遍历