### LRU 淘汰算法

#### 什么是LRU？

最近最少使用算法，是一种缓存的淘汰算法策略

#### 怎么设计？

1. 需求

   + 快速访问元素
   + 快速删除元素

2. 设计

   散列表：可以满足元素快速访问的需求

   链表：可以满足对元素快速增加或删除的需求

   ![LRU](pic/LRU.jpeg)

   注意，链表的结点中，保存着三个指针，prev、next目的是使得元素可以顺序访问，hnext目的是解决散列表的哈希冲突使用链表法解决时将结点串起来的指针

3. 对比之前

   之前设计缓存，只用链表结构，那么时间复杂度是O(n),而现在加入散列表，操作的时间复杂度是O(1)

### Redis 有序集合

#### 功能

+ 添加一个成员对象；按照键值来删除一个成员对象；
+ 按照键值来查找一个成员对象；
+ 按照**分值**区间查找数据，比如查找积分在[100, 356]之间的成员对象；
+ 按照**分值**从小到大排序成员变量； --- 目前未知

#### 实现

跳表：按照分值构造跳表，可以保证元素按照 score 区间进行快速访问

散列表：按照键值构建散列表，保证元素的快速访问和增删操作

### Java LinkedHashMap

#### 数据结构

双向链表 + 散列表

#### 具体行为

插入新的元素或者发现已经有插入的元素则先删除，把此元素放置于链表的尾端

### 分析

此数据结构非常方便实现基于LRU淘汰策略的缓存系统

### 问题

1. 为什么散列表和链表经常一起使用？

   散列表的优势在于对数据的访问，时间复杂度O(1),但是不能按照某种顺序访问散列表里面的元素。链表正好可以支持数据的顺序遍历

2. 如果把双向链表改为单向链表，还能否正常工作？

   可以，不过提高了时间复杂度。特别是删除操作，从O(1)变为O(n)

3. 假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：

   + 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；
   + 查找积分在某个区间的猎头 ID 列表；
   + 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。

   思想类似Redis的有序列表，用ID构建散列表，积分构建跳表

4. 某个网友的总结

   通过这 20 节课学习下来，个人感觉其实就两种数据结构，链表和数组。

   数组占据随机访问的优势，却有需要连续内存的缺点。

   链表具有可不连续存储的优势，但访问查找是线性的。

   散列表和链表、跳表的混合使用，是为了结合数组和链表的优势，规避它们的不足。

   我们可以得出数据结构和算法的重要性排行榜：连续空间 > 时间 > 碎片空间。



